\section{The code for NMO}

Now I'll show how to implement the above algorithm in Python using the numpy and scipy libraries.
We'll split the algorithm into three functions.
This is very important when programming any moderately complex code because it allows us to test each part of our code independently.
This reduces the amount of code we have to search through to find that bug is messing up our results.
Modular code is also easier to understand and to reuse.

The first function I'll define performs the NMO correction on a given CMP gather.
We'll assume that the CMP gather is a 2D numpy array of amplitudes and that the
velocities are a 1D numpy array with $v_{NMO}$ for each time sample.

\begin{lstlisting}[language=python]
    import numpy as np
    
    def nmo_correction(cmp, dt, offsets, velocities):
        nmo = np.zeros_like(cmp)
        nsamples = cmp.shape[0]
        times = np.arange(0, nsamples*dt, dt)
        for i, t0 in enumerate(times):
            for j, x in enumerate(offsets):
                t = reflection_time(t0, x, velocities[i])
                amplitude = sample_trace(cmp[:, j], t, dt)
                # If the time t is outside of the CMP time range,
                # amplitude will be None.
                if amplitude is not None:
                    nmo[i, j] = amplitude
        return nmo
\end{lstlisting}

This function is essentially the algorithm above translated to Python with some
of the details pushed into the \texttt{reflection_time} and
\texttt{sample_trace} functions.

Now we need to define the function that calculates the reflection travel-time.

\begin{lstlisting}[language=python]
def reflection_time(t0, offset, velocity):
    t = np.sqrt(t0**2 + offset**2/velocity**2)
    return t
\end{verbatim}

For the \texttt{sample_trace} function, we'll use cubic splines from the
\texttt{scipy.interpolate} package.
For more information on interpolation with scipy, see the tutorial by
\citet{Hall_2016}.

\begin{verbatim}
from scipy.interpolate import CubicSpline

def sample_trace(trace, time, dt):
    # The floor function will give us the integer
    # right behind a given float.
    before = int(np.floor(time/dt))
    nsamples = trace.size
    # Use the 4 samples around 'time' to interpolate
    # the amplitude
    samples = np.arange(before - 1, before + 3, 1)
    # Check if any sample falls outside of our trace
    if np.any(samples < 0) or np.any(samples >= nsamples):
        amplitude = None
    else:
        times = dt*samples
        amps = trace[samples]
        interpolator = CubicSpline(times, amps)
        amplitude = interpolator(time)
    return amplitude
\end{verbatim}

The Jupyter notebook contains the full code for these functions, including
documentation through Python \textit{dostrings} and code that tests that the
functions work as expected.
Also included is an application of our \texttt{nmo_correction} function to a
synthetic CMP (Figure 2).
